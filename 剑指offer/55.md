剑指 Offer 55 - I. 二叉树的深度
====
https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/

> [方法一： DFS]()<br>
> [方法二： BFS]()<br>

## 题目描述

方法一： DFS
====
## 思路
疫苗第二针打完了， 烧了一天一夜我又复活了 ✌️。

来补前两天的 md 了。

## 代码
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        ans = 0
        queue = []
        queue.append(root)
        while queue:
            level = queue
            for node in level:
                cur = level.pop()
                if cur.left:
                    level.append(cur.left)
                if cur.right:
                    level.append(cur.right)
            queue = level
            ans += 1
        return ans
```

## 复杂度分析
- 时间复杂度：
- 空间复杂度：

方法二： BFS
====
## 思路
BFS。

将 DFS 递归可视化。

这道题 BFS 不用队列来做了， 用数组。

因为要比较左右子树的层数最大值， 所以要将层信息 level 单拿出来比较节点层数的最大值。

就像上面 DFS 中的这一行代码。 ` `


## 代码
```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        ans = 0
        queue = []
        queue.append(root)
        while queue:
            level = queue
            for node in level:
                cur = level.pop(0)
                if cur.left:
                    level.append(cur.left)
                if cur.right:
                    level.append(cur.right)
            queue = level
            ans += 1
        return ans
```

## 复杂度分析
- 时间复杂度：
- 空间复杂度：
